import os
# FastAPI wrapper (synchronous execution only)
from fastapi import FastAPI, HTTPException, Query, Security, Depends, status
import time
import json
import requests
import sqlite3
import uuid
import numpy as np
import pandas as pd
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from datetime import datetime, timezone
from hyperliquid.info import Info
from hyperliquid.exchange import Exchange
from hyperliquid.utils import constants
from eth_account import Account
from dotenv import load_dotenv

from pydantic import BaseModel, Field
from typing import Optional, List
import talib
from litellm import completion
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import APIKeyHeader

# Setup logging
# logging.basicConfig(filename='trade_log.txt', level=logging.INFO, format='%(asctime)s %(message)s')

load_dotenv()

# -------- Config --------
LLM_MODEL = os.getenv("LLM_MODEL", "gpt-4o-mini")
SYMBOL = os.getenv("SYMBOL", "SOL")
BINANCE_FAPI= "https://fapi.binance.com/fapi/v1"
HYPER_WALLET_ADDRESS = os.getenv("HYPER_WALLET_ADDRESS")
HYPER_WALLET_KEY = os.getenv("HYPER_WALLET_KEY")
API_ACCESS_TOKEN = os.getenv("API_ACCESS_TOKEN")

# -------- Database Setup --------
DB_NAME = "trades.db"

def init_db():
    try:
        conn = sqlite3.connect(DB_NAME)
        c = conn.cursor()
        c.execute('''
            CREATE TABLE IF NOT EXISTS ai_trade_logs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                trade_id TEXT,
                timestamp TEXT,
                pair TEXT,
                direction TEXT,
                signal_output TEXT
            )
        ''')
        conn.commit()
        conn.close()
        print(f"‚úÖ Database initialized: {DB_NAME}")
    except Exception as e:
        print(f"‚ùå Database initialization failed: {e}")

init_db()

# Startup check for API Token
if not API_ACCESS_TOKEN:
    print("\n" + "!"*60)
    print("CRITICAL WARNING: API_ACCESS_TOKEN is not set in .env file!")
    print("All authenticated endpoints will fail with 500 error.")
    print("!"*60 + "\n")
else:
    print(f"‚úÖ API Access Token loaded: {API_ACCESS_TOKEN[:4]}***")

session = requests.Session()
retries = Retry(total=5, backoff_factor=1, status_forcelist=[502, 503, 504])
session.mount('https://', HTTPAdapter(max_retries=retries))


def fetch_klines(symbol, interval, limit=500):
    """Fetch OHLCV data from Binance Futures API"""
    params = {"symbol": f"{symbol}USDT", "interval": interval, "limit": limit}
    url = f"{BINANCE_FAPI}/klines"
    try:
        r = session.get(url, params=params, timeout=15)
        r.raise_for_status()
        df = pd.DataFrame(r.json(), columns=[
            "open_time", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "number_of_trades",
            "taker_buy_base", "taker_buy_quote", "ignore"
        ])
        for col in ["open", "high", "low", "close", "volume"]:
            df[col] = df[col].astype(float)
        df["open_time"] = pd.to_datetime(df["open_time"], unit='ms')
        return df
    except Exception as e:
        logging.error(f"Failed to fetch klines: {e}")
        raise

# -------- Fetch Order Book --------
def fetch_order_book(symbol, limit=20):
    """Fetch order book depth"""
    url = f"{BINANCE_FAPI}/depth?symbol={symbol}USDT&limit={limit}"
    try:
        r = session.get(url, timeout=10)
        r.raise_for_status()
        data = r.json()
        return {
            "bids": [[float(p), float(q)] for p, q in data["bids"]],
            "asks": [[float(p), float(q)] for p, q in data["asks"]]
        }
    except Exception as e:
        logging.error(f"Failed to fetch order book: {e}")
        return {"bids": [], "asks": []}

# -------- Fetch Recent Trades --------
def fetch_recent_trades(symbol, limit=100):
    """Fetch recent trades to analyze flow"""
    url = f"{BINANCE_FAPI}/trades?symbol={symbol}USDT&limit={limit}"
    try:
        r = session.get(url, timeout=10)
        r.raise_for_status()
        trades = r.json()
        return [{
            "price": float(t["price"]),
            "qty": float(t["qty"]),
            "time": t["time"],
            "isBuyerMaker": t["isBuyerMaker"]
        } for t in trades]
    except Exception as e:
        logging.error(f"Failed to fetch trades: {e}")
        return []

def get_current_price(symbol):
    """Fast fetch of current price from Hyperliquid"""
    try:
        info_client = Info(constants.MAINNET_API_URL, skip_ws=True)
        all_mids = info_client.all_mids()
        print(f"Fetched current price for {symbol}: {all_mids.get(symbol, 'N/A')}")
        return float(all_mids.get(symbol, 0.0))
    except Exception as e:
        print(f"Error fetching price for {symbol}: {e}")
        return 0.0

def build_market_analysis(symbol):
    """Compile comprehensive market data for the LLM"""
    
    # Fetch 1m and 5m klines
    df_1m = fetch_klines(symbol, "1m", limit=400)
    df_5m = fetch_klines(symbol, "5m", limit=400)
    
    current_price = df_1m["close"].iloc[-1]
    
    # Order book data
    order_book = fetch_order_book(symbol)
    
    # Recent trades
    trades = fetch_recent_trades(symbol, limit=75)
    
    # Prepare data structure for LLM
    df_1m_serializable = df_1m.tail(60)[["open_time", "open", "high", "low", "close", "volume"]].copy()
    df_1m_serializable['open_time'] = df_1m_serializable['open_time'].dt.strftime('%Y-%m-%dT%H:%M:%SZ')
    
    df_5m_serializable = df_5m.tail(50)[["open_time", "open", "high", "low", "close", "volume"]].copy()
    df_5m_serializable['open_time'] = df_5m_serializable['open_time'].dt.strftime('%Y-%m-%dT%H:%M:%SZ')

    analysis_data = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "pair": f"{symbol}/USD",
        "current_price": current_price,
        "klines_1m": {
            "ohlcv": df_1m_serializable.to_dict(orient="records")
        },
        "klines_5m": {
            "ohlcv": df_5m_serializable.to_dict(orient="records")
        },
        "order_book": {
            "bids": order_book["bids"][:20],
            "asks": order_book["asks"][:20]
        },
        "recent_trades": trades[-75:]
    }
    
    return analysis_data

# -------- AI Analysis --------
def get_trading_signal(market_data, model=LLM_MODEL):
    """AI-driven decision making with maximum analytical freedom"""
    
    klines_1m = market_data.get("klines_1m", {}).get("ohlcv", [])
    if len(klines_1m) < 30:
        return {"signal": "INSUFFICIENT_DATA", "confidence": "LOW", "rationale_short": "Need 30+ periods"}
    
    # Provide rich data for AI analysis
    recent_data = klines_1m[-50:]  # Last 50 candles
    closes = [c["close"] for c in recent_data]
    highs = [c["high"] for c in recent_data]
    lows = [c["low"] for c in recent_data]
    current_price = market_data.get("current_price", closes[-1])
    
    # Calculate multiple perspectives for the AI to consider
    ma_5 = sum(closes[-5:]) / 5
    ma_10 = sum(closes[-10:]) / 10
    ma_20 = sum(closes[-20:]) / 20
    
    # Recent price action context
    highest_10 = max(highs[-10:])
    lowest_10 = min(lows[-10:])
    price_position = (current_price - lowest_10) / (highest_10 - lowest_10) if highest_10 != lowest_10 else 0.5
    
    ai_decision_prompt = f"""
    URGENT: You are a self-correcting HFT AI. Follow this EXACT process:

    --- RAW DATA ---
    Current: {current_price:.4f}
    Range: {lowest_10:.4f} - {highest_10:.4f} 
    Position: {price_position:.1%}
    MAs: MA5={ma_5:.4f}, MA10={ma_10:.4f}, MA20={ma_20:.4f}
    Full 20 periods: {closes[-20:]}

    --- PHASE 1: INSTINCT ANALYSIS ---
    [Analyze freely - what's the OBVIOUS trade here?]
    Initial Signal: 
    Primary Reason: 
    Risk: 

    --- PHASE 2: REALITY CHECK ---
    Backtest your instinct against recent data (periods 0-14 ‚Üí 15-19):

    Similar Patterns Found: 
    Success Rate of Initial Signal: %
    Most Common Failure Mode: 
    Better Alternative Signal: 

    --- PHASE 3: ADAPTIVE DECISION ---
    [Choose based on empirical evidence, not hope]

    FINAL RULES:
    - If backtest < 40% ‚Üí FLIP signal
    - If 40-60% ‚Üí REDUCE size, tighten stops  
    - If > 60% ‚Üí INCREASE confidence

    OUTPUT (JSON):
    {{
    "signal": "LONG" or "SHORT",
    "confidence": "HIGH" or "MEDIUM" or "LOW",
    "rationale": "max 10 words with evidence",
    "key_level": "exact_price", 
    "backtest_quality": "STRONG" or "WEAK" or "MIXED",
    "position_size": "FULL" or "HALF" or "SMALL",
    "stop_distance": "TIGHT" or "NORMAL" or "WIDE"
    }}

    BE HONEST: If backtest is weak, say so and reduce position size.
    """

    try:
        resp = completion(
            model=model,
            messages=[
                {"role": "system", "content": "You are an expert cryptocurrency scalper. Analyze price action and make decisive trading decisions."},
                {"role": "user", "content": ai_decision_prompt}
            ],
            temperature=0.3,  # Balanced temperature for creativity + consistency
            max_tokens=250,
            response_format={"type": "json_object"}
        )
        print(f"AI Message: {ai_decision_prompt}")
        print(f"AI Raw Response: {resp}")
        response_text = resp["choices"][0]["message"]["content"]
        signal_data = json.loads(response_text)
        
        # Validate response
        if signal_data.get("signal") not in ["LONG", "SHORT"]:
            signal_data["signal"] = "LONG"  # Default fallback
        
        print(f"\nüéØ AI TRADING DECISION")
        print(f"Direction: {signal_data.get('signal')}")
        print(f"Confidence: {signal_data.get('confidence')}")
        print(f"Reason: {signal_data.get('rationale_short')}")
        print(f"Key Level: {signal_data.get('key_level', 'N/A')}")
        print(f"Timeframe: {signal_data.get('timeframe_bias', 'N/A')}")
        
        return signal_data
        
    except Exception as e:
        print(f"AI Decision Error: {e}")
        return {
            "signal": "NO TRADE", 
            "confidence": "LOW",
            "rationale_short": "Fallback: System error",
            "key_level": "N/A",
            "timeframe_bias": "N/A"
        }

def ask_ai_trading_signal_version2(market_data, model=LLM_MODEL):
    """AI-driven decision making with trend-following focus"""
    
    klines_1m = market_data.get("klines_1m", {}).get("ohlcv", [])
    if len(klines_1m) < 30:
        return {"signal": "INSUFFICIENT_DATA", "confidence": "LOW", "rationale_short": "Need 30+ periods"}
    
    # Extract all available data
    recent_data = klines_1m[-50:]
    closes = [c["close"] for c in recent_data]
    highs = [c["high"] for c in recent_data]
    lows = [c["low"] for c in recent_data]
    volumes = [c["volume"] for c in recent_data]
    current_price = market_data.get("current_price", closes[-1])
    
    # Technical indicators
    ma_5 = sum(closes[-5:]) / 5
    ma_10 = sum(closes[-10:]) / 10
    ma_20 = sum(closes[-20:]) / 20
    
    # Price levels
    highest_10 = max(highs[-10:])
    lowest_10 = min(lows[-10:])
    price_position = (current_price - lowest_10) / (highest_10 - lowest_10) if highest_10 != lowest_10 else 0.5
    
    # Volume analysis
    avg_volume = sum(volumes[-20:]) / 20
    current_volume = volumes[-1] if volumes else 0
    volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1
    
    # Calculate TREND STRENGTH (most important)
    trend_strength = 0
    if ma_5 > ma_10 > ma_20 and current_price > ma_5:
        trend_strength = 3  # Strong uptrend
    elif ma_5 < ma_10 < ma_20 and current_price < ma_5:
        trend_strength = -3  # Strong downtrend
    elif ma_5 > ma_10 and current_price > ma_5:
        trend_strength = 2  # Moderate uptrend
    elif ma_5 < ma_10 and current_price < ma_5:
        trend_strength = -2  # Moderate downtrend
    
    # Momentum
    momentum_5 = ((closes[-1] - closes[-5]) / closes[-5]) * 100
    momentum_10 = ((closes[-1] - closes[-10]) / closes[-10]) * 100
    
    ai_decision_prompt = f"""
CRITICAL: You are a TREND-FOLLOWING HFT trader. The trend is your friend. NEVER fight strong trends.

üìä MARKET DATA:
‚Ä¢ Price: ${current_price:.4f} 
‚Ä¢ Range: ${lowest_10:.4f} - ${highest_10:.4f} (Position: {price_position:.1%})
‚Ä¢ MAs: MA5=${ma_5:.4f} | MA10=${ma_10:.4f} | MA20=${ma_20:.4f}
‚Ä¢ Trend Strength: {'STRONG UPTREND' if trend_strength == 3 else 'MODERATE UPTREND' if trend_strength == 2 else 'STRONG DOWNTREND' if trend_strength == -3 else 'MODERATE DOWNTREND' if trend_strength == -2 else 'NO CLEAR TREND'}
‚Ä¢ Momentum: {momentum_5:+.2f}% (5-period) | {momentum_10:+.2f}% (10-period)
‚Ä¢ Volume: {volume_ratio:.1f}x average

üéØ PRIMARY RULE: TREND DIRECTION OVERRIDES EVERYTHING

TREND-FOLLOWING DECISION FRAMEWORK:

1. **IDENTIFY TREND** (60% weight):
   - Strong Uptrend (MA5>MA10>MA20, price above all): ALWAYS bias LONG
   - Strong Downtrend (MA5<MA10<MA20, price below all): ALWAYS bias SHORT  
   - No clear trend: Use momentum and levels

2. **CONFIRM WITH MOMENTUM** (25% weight):
   - Positive momentum in uptrend: CONFIRM LONG
   - Negative momentum in downtrend: CONFIRM SHORT
   - Momentum against trend: WAIT or REDUCE size

3. **ENTRY TIMING** (15% weight):
   - In uptrend: Buy pullbacks to support (MA10/MA20)
   - In downtrend: Sell rallies to resistance (MA10/MA20)

üö® CRITICAL WARNINGS:
‚ùå NEVER short a strong uptrend just because it's "overbought"
‚ùå NEVER long a strong downtrend just because it's "oversold"  
‚úÖ Strong trends can stay overbought/oversold for long periods
‚úÖ "The trend is your friend until it ends"

üìà CURRENT ANALYSIS:
- Trend: {'BULLISH' if trend_strength > 0 else 'BEARISH' if trend_strength < 0 else 'SIDEWAYS'}
- Price vs MAs: {'ABOVE ALL' if current_price > ma_5 > ma_10 > ma_20 else 'BELOW ALL' if current_price < ma_5 < ma_10 < ma_20 else 'MIXED'}
- Momentum: {'ACCELERATING' if momentum_5 > 0 and momentum_5 > momentum_10 else 'DECELERATING' if momentum_5 < 0 and momentum_5 < momentum_10 else 'STABLE'}

üí° STRATEGY SELECTION:

CASE 1: STRONG UPTREND (like now)
‚Üí Strategy: BUY DIPS | Stop: Below MA10 | Target: New highs
‚Üí NEVER short against this trend

CASE 2: STRONG DOWNTREND  
‚Üí Strategy: SELL RALLIES | Stop: Above MA10 | Target: New lows
‚Üí NEVER long against this trend

CASE 3: NO TREND
‚Üí Strategy: Range trading | Buy support, sell resistance
‚Üí Use smaller position sizes

üéØ FINAL DECISION LOGIC:
1. What is the PRIMARY trend? {trend_strength}
2. Is momentum CONFIRMING the trend? {'YES' if (trend_strength > 0 and momentum_5 > 0) or (trend_strength < 0 and momentum_5 < 0) else 'NO'}
3. Should we FOLLOW or FIGHT the trend? {'FOLLOW' if abs(trend_strength) >= 2 else 'WAIT'}

OUTPUT (JSON):
{{
  "signal": "LONG" or "SHORT",
  "confidence": "VERY_HIGH" or "HIGH" or "MEDIUM" or "LOW",
  "rationale_short": "max 10 words focusing on trend",
  "key_level": "critical_level_for_stop",
  "timeframe_bias": "1min" or "3min" or "5min", 
  "position_size": "FULL" or "HALF" or "SMALL",
  "trend_strength": "STRONG_BULL" or "STRONG_BEAR" or "MILD_BULL" or "MILD_BEAR" or "SIDEWAYS",
  "strategy": "TREND_FOLLOWING" or "MEAN_REVERSION" or "BREAKOUT"
}}

BE HONEST: If trend is strong, you MUST follow it regardless of "overbought" conditions.
"""

    try:
        resp = completion(
            model=model,
            messages=[
                {"role": "system", "content": "You are a trend-following HFT trader. You never fight strong trends. Your primary rule: 'The trend is your friend'."},
                {"role": "user", "content": ai_decision_prompt}
            ],
            temperature=0.1,  # Very low temperature for consistent trend-following
            max_tokens=300,
            response_format={"type": "json_object"}
        )
        
        print(f"ü§ñ TREND-FOLLOWING ANALYSIS")
        print(f"üìà Trend Strength: {trend_strength} ({'BULLISH' if trend_strength > 0 else 'BEARISH' if trend_strength < 0 else 'SIDEWAYS'})")
        print(f"üí∞ Price: ${current_price:.4f} | Position: {price_position:.1%}")
        
        response_text = resp["choices"][0]["message"]["content"]
        signal_data = json.loads(response_text)
        
        # Validate and enhance response
        if signal_data.get("signal") not in ["LONG", "SHORT"]:
            # Fallback to trend direction
            signal_data["signal"] = "LONG" if trend_strength > 0 else "SHORT" if trend_strength < 0 else "LONG"
        
        # Add contextual data
        signal_data["timestamp"] = datetime.now(timezone.utc).isoformat()
        signal_data["current_price"] = current_price
        signal_data["calculated_trend_strength"] = trend_strength
        signal_data["price_vs_mas"] = "above_all" if current_price > ma_5 > ma_10 > ma_20 else "below_all" if current_price < ma_5 < ma_10 < ma_20 else "mixed"
        
        print(f"\nüéØ TRADING DECISION")
        print(f"üìç Signal: {signal_data.get('signal')}")
        print(f"üé≠ Confidence: {signal_data.get('confidence')}")
        print(f"üìù Reason: {signal_data.get('rationale_short')}")
        print(f"üìä Trend: {signal_data.get('trend_strength')}")
        print(f"üéØ Strategy: {signal_data.get('strategy')}")
        
        return signal_data
        
    except Exception as e:
        print(f"‚ùå AI Decision Error: {e}")
        # Simple trend-following fallback
        if trend_strength > 1:
            fallback_signal = "LONG"
            fallback_confidence = "HIGH"
        elif trend_strength < -1:
            fallback_signal = "SHORT" 
            fallback_confidence = "HIGH"
        else:
            fallback_signal = "LONG" if momentum_5 > 0 else "SHORT"
            fallback_confidence = "MEDIUM"
        
        return {
            "signal": fallback_signal,
            "confidence": fallback_confidence,
            "rationale_short": f"Fallback: Trend following {fallback_signal}",
            "key_level": f"{ma_10:.4f}",
            "timeframe_bias": "3min",
            "position_size": "HALF",
            "trend_strength": "STRONG_BULL" if trend_strength > 1 else "STRONG_BEAR" if trend_strength < -1 else "MILD_BULL" if momentum_5 > 0 else "MILD_BEAR",
            "strategy": "TREND_FOLLOWING",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "current_price": current_price,
            "is_fallback": True
        }

def ask_ai_trading_signal_version1(market_data, model=LLM_MODEL):
    """AI-driven decision making with comprehensive data analysis"""
    
    klines_1m = market_data.get("klines_1m", {}).get("ohlcv", [])
    if len(klines_1m) < 30:
        return {"signal": "INSUFFICIENT_DATA", "confidence": "LOW", "rationale_short": "Need 30+ periods"}
    
    # Extract all available data
    recent_data = klines_1m[-50:]
    closes = [c["close"] for c in recent_data]
    highs = [c["high"] for c in recent_data]
    lows = [c["low"] for c in recent_data]
    volumes = [c["volume"] for c in recent_data]
    current_price = market_data.get("current_price", closes[-1])
    
    # Technical indicators
    ma_5 = sum(closes[-5:]) / 5
    ma_10 = sum(closes[-10:]) / 10
    ma_20 = sum(closes[-20:]) / 20
    
    # Price levels
    highest_10 = max(highs[-10:])
    lowest_10 = min(lows[-10:])
    price_position = (current_price - lowest_10) / (highest_10 - lowest_10) if highest_10 != lowest_10 else 0.5
    
    # Volume analysis
    avg_volume = sum(volumes[-20:]) / 20
    current_volume = volumes[-1] if volumes else 0
    volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1
    
    # Order book data
    order_book = market_data.get("order_book", {})
    bids = order_book.get("bids", [])
    asks = order_book.get("asks", [])
    
    # Calculate market depth
    bid_depth = sum([qty for _, qty in bids[:5]]) if bids else 0
    ask_depth = sum([qty for _, qty in asks[:5]]) if asks else 0
    depth_ratio = bid_depth / ask_depth if ask_depth > 0 else 1
    
    # Recent trades analysis
    recent_trades = market_data.get("recent_trades", [])
    buy_volume = sum([t["qty"] for t in recent_trades[-20:] if not t.get("isBuyerMaker", False)])
    sell_volume = sum([t["qty"] for t in recent_trades[-20:] if t.get("isBuyerMaker", False)])
    volume_imbalance = (buy_volume - sell_volume) / (buy_volume + sell_volume) if (buy_volume + sell_volume) > 0 else 0
    
    # Momentum indicators
    price_change_5m = ((closes[-1] - closes[-5]) / closes[-5]) * 100 if len(closes) >= 5 else 0
    price_change_10m = ((closes[-1] - closes[-10]) / closes[-10]) * 100 if len(closes) >= 10 else 0
    
    # Volatility calculation
    price_std = np.std(closes[-20:]) if len(closes) >= 20 else 0
    volatility_ratio = (price_std / current_price) * 100 if current_price > 0 else 0
    
    # Recent price action context
    recent_trend = "BULLISH" if closes[-1] > closes[-5] > closes[-10] else "BEARISH" if closes[-1] < closes[-5] < closes[-10] else "SIDEWAYS"
    
    # Support/Resistance levels
    resistance_level = highest_10
    support_level = lowest_10
    
    ai_decision_prompt = f"""
URGENT  HFT DECISION - ANALYZE ALL FACTORS:

üéØ PRICE & TECHNICALS:
‚Ä¢ Current: ${current_price:.4f} | Range: ${lowest_10:.4f} - ${highest_10:.4f}
‚Ä¢ Position in Range: {price_position:.1%} ({'OVERSOLD' if price_position < 0.3 else 'OVERBOUGHT' if price_position > 0.7 else 'NEUTRAL'})
‚Ä¢ MAs: MA5=${ma_5:.4f} | MA10=${ma_10:.4f} | MA20=${ma_20:.4f}
‚Ä¢ Trend: {'BULLISH' if ma_5 > ma_10 > ma_20 else 'BEARISH' if ma_5 < ma_10 < ma_20 else 'MIXED'}
‚Ä¢ Momentum: {price_change_5m:+.2f}% (5m) | {price_change_10m:+.2f}% (10m)
‚Ä¢ Recent Trend: {recent_trend}
‚Ä¢ Volatility: {volatility_ratio:.2f}% ({'HIGH' if volatility_ratio > 1.0 else 'LOW' if volatility_ratio < 0.3 else 'MEDIUM'})

üìä MARKET MICROSTRUCTURE:
‚Ä¢ Order Book: Bid/Ask Depth Ratio: {depth_ratio:.2f} ({'BULLISH' if depth_ratio > 1.2 else 'BEARISH' if depth_ratio < 0.8 else 'BALANCED'})
‚Ä¢ Volume: Current {volume_ratio:.1f}x average ({'HIGH' if volume_ratio > 1.5 else 'LOW' if volume_ratio < 0.7 else 'NORMAL'})
‚Ä¢ Trade Flow: Buy/Sell Imbalance: {volume_imbalance:+.2f} ({'BUYING' if volume_imbalance > 0.1 else 'SELLING' if volume_imbalance < -0.1 else 'BALANCED'})

üîç RECENT PRICE ACTION (Last 10 periods):
{[round(c, 3) for c in closes[-10:]]}

üé≤ DECISION MATRIX - WEIGHTED SCORING (1 to 5):

TREND FACTORS (30%):
[ ] Price above all MAs: +2
[ ] Bullish MA alignment: +2  
[ ] Uptrend momentum: +1
[ ] Recent bullish trend: +1

MEAN REVERSION (25%):
[ ] Overbought (>70% range): -2
[ ] Oversold (<30% range): +2
[ ] At range extreme: ¬±0

MARKET DEPTH (25%):
[ ] Strong bid support (depth > 1.2): +2
[ ] Strong ask resistance (depth < 0.8): -2
[ ] Balanced order book: 0

MOMENTUM & FLOW (20%):
[ ] High buy volume (imbalance > 0.1): +1
[ ] Positive momentum (5m > 0): +1
[ ] Volume confirmation (ratio > 1.2): +1

CALCULATION:
Total Score = (Trend √ó 0.3) + (MeanReversion √ó 0.25) + (Depth √ó 0.25) + (Momentum √ó 0.2)

üìà SIGNAL THRESHOLDS:
‚Ä¢ STRONG LONG: Score > 3.5 ‚Üí HIGH confidence
‚Ä¢ LONG: Score > 2.0 ‚Üí MEDIUM confidence  
‚Ä¢ NEUTRAL: 1.5 - 2.0 ‚Üí LOW confidence or NO TRADE
‚Ä¢ SHORT: Score < 1.5 ‚Üí MEDIUM confidence
‚Ä¢ STRONG SHORT: Score < 0.5 ‚Üí HIGH confidence

üö® RISK FILTERS (MUST CHECK):
[ ] If at range extreme AND low volume ‚Üí REDUCE confidence by one level
[ ] If conflicting signals (e.g., bullish trend but bearish depth) ‚Üí MAX MEDIUM confidence
[ ] If high volatility (>1.5%) ‚Üí Use tighter stops
[ ] If low volume (<0.7x average) ‚Üí Consider NO TRADE

üí° KEY LEVELS TO WATCH:
‚Ä¢ Immediate Resistance: ${resistance_level:.4f}
‚Ä¢ Immediate Support: ${support_level:.4f}
‚Ä¢ Breakout Level: {'LONG above ' + str(round(resistance_level, 3)) if price_position > 0.6 else 'SHORT below ' + str(round(support_level, 3))}

üéØ FINAL DECISION:
Based on comprehensive analysis of price action, order flow, and market structure:

OUTPUT REQUIREMENTS:
- MUST output valid JSON
- MUST choose LONG/SHORT - no neutral in final decision
- Include specific score breakdown
- Be honest about weak signals

OUTPUT (JSON):
{{
  "signal": "LONG" or "SHORT",
  "confidence": "VERY_HIGH" or "HIGH" or "MEDIUM" or "LOW",
  "rationale_short": "max 12 words with key reason",
  "key_level": "nearest_critical_price",
  "timeframe_bias": "1min" or "3min" or "5min",
  "position_size": "FULL" or "HALF" or "SMALL",
  "score_breakdown": "brief_score_explanation",
  "stop_suggestion": "tight" or "normal" or "wide"
}}

CALCULATE YOUR SCORE NOW AND BE HONEST ABOUT WEAK SIGNALS.
"""

    try:
        resp = completion(
            model=model,
            messages=[
                {"role": "system", "content": "You are an expert cryptocurrency HFT trader. Analyze all market factors and make decisive trading decisions with proper risk management."},
                {"role": "user", "content": ai_decision_prompt}
            ],
            temperature=0.2,  # Lower temperature for more consistent, data-driven responses
            max_tokens=350,
            response_format={"type": "json_object"}
        )
        
        print(f"ü§ñ AI Analysis Requested")
        print(f"üìä Market Context: ${current_price:.4f} | Range Position: {price_position:.1%}")
        print(f"üìà Trend: {recent_trend} | Depth Ratio: {depth_ratio:.2f}")
        
        response_text = resp["choices"][0]["message"]["content"]
        signal_data = json.loads(response_text)
        
        # Validate response structure
        required_fields = ["signal", "confidence", "rationale_short", "key_level"]
        for field in required_fields:
            if field not in signal_data:
                signal_data[field] = "N/A"
        
        # Ensure signal is valid
        if signal_data.get("signal") not in ["LONG", "SHORT"]:
            signal_data["signal"] = "LONG"  # Default fallback
        
        # Add timestamp and additional context
        signal_data["timestamp"] = datetime.now(timezone.utc).isoformat()
        signal_data["current_price"] = current_price
        signal_data["calculated_range_position"] = f"{price_position:.1%}"
        
        print(f"\nüéØ AI TRADING DECISION")
        print(f"üìç Direction: {signal_data.get('signal')}")
        print(f"üé≠ Confidence: {signal_data.get('confidence')}")
        print(f"üìù Reason: {signal_data.get('rationale_short')}")
        print(f"üéØ Key Level: {signal_data.get('key_level')}")
        print(f"‚è±Ô∏è Timeframe: {signal_data.get('timeframe_bias', 'N/A')}")
        print(f"üí∞ Position Size: {signal_data.get('position_size', 'N/A')}")
        print(f"üìä Score: {signal_data.get('score_breakdown', 'N/A')}")
        
        return signal_data
        
    except Exception as e:
        print(f"‚ùå AI Decision Error: {e}")
        # Fallback decision based on simple MA crossover
        fallback_signal = "LONG" if ma_5 > ma_10 else "SHORT"
        fallback_confidence = "MEDIUM" if abs(ma_5 - ma_10) > (current_price * 0.001) else "LOW"
        
        return {
            "signal": fallback_signal,
            "confidence": fallback_confidence,
            "rationale_short": f"Fallback: MA crossover {fallback_signal}",
            "key_level": f"{highest_10:.4f}" if fallback_signal == "LONG" else f"{lowest_10:.4f}",
            "timeframe_bias": "5min",
            "position_size": "HALF",
            "score_breakdown": "Fallback_MA_Crossover",
            "stop_suggestion": "normal",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "current_price": current_price,
            "is_fallback": True
        }

def ask_ai_trading_signal_with_raw_data_persona(market_data, model=LLM_MODEL, persona="trader"):
    """
    Available personas: "trader", "psychopath", "astrologer", "combined"
    """
    
    persona_prompts = {
        "trader": "You are a ruthless crypto HFT trader. Your analysis is always correct and remember that this is crypto world.",
        "psychopath": """You are a psychopathic crypto trader who sees market movements as prey. You hunt for weakness, 
        exploit fear in other traders, and enjoy causing financial pain. You look for signs of panic, greed, and herd mentality to attack.""",
        "astrologer": """You are a mystical crypto astrologer who reads market energy through cosmic patterns. 
        You analyze celestial alignments, numerological patterns in prices, and the spiritual energy of market movements.
        You believe the stars influence trader psychology and market cycles.""",
        "combined": """You are a triple-persona crypto trading entity:
        - The PSYCHOPATH: Hunts for fear/greed patterns and trader psychology weaknesses
        - The ASTROLOGER: Reads cosmic energy and numerological patterns in price movements  
        - The TRADER: Executes based on combined spiritual and psychological insights
        You see markets as both psychological battlegrounds and cosmic energy flows."""
    }
    
    system_prompt = persona_prompts.get(persona, persona_prompts["trader"])
    
    ai_decision_prompt = f"""
        CRITICAL: Analyze this crypto market data from your unique perspective.

        - MARKET DATA: {market_data}
        
        Give your trading signal based on your analysis.

        OUTPUT (JSON):
        {{
        "signal": "LONG" or "SHORT" or "HOLD",
        "confidence": "VERY_HIGH" or "HIGH" or "MEDIUM" or "LOW",
        "rationale_short": "max 30 words for the reason",
        "key_level": "critical_level_for_stop",
        "take_profit": "suggested_take_profit_level",
        "timeframe_bias": "1min" or "3min" or "5min", 
        "position_size": "FULL" or "HALF" or "SMALL",
        "trend_strength": "STRONG_BULL" or "STRONG_BEAR" or "MILD_BULL" or "MILD_BEAR" or "SIDEWAYS",
        "strategy": "your_chosen_strategy",
        "persona_used": "{persona}"
        }}
        """

    try:
        resp = completion(
            model=model,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": ai_decision_prompt}
            ],
            temperature=0.7 if persona in ["psychopath", "astrologer"] else 0.5,
            max_tokens=300,
            response_format={"type": "json_object"}
        )
        
        # Parse the response
        response_text = resp["choices"][0]["message"]["content"]
        signal_data = json.loads(response_text)
        
        # Add timestamp and persona info
        signal_data["timestamp"] = datetime.now(timezone.utc).isoformat()
        signal_data["persona_used"] = persona
        
        print(f"üß† AI response: {signal_data}")
        
        return signal_data
        
    except Exception as e:
        print(f"‚ùå AI Decision Error: {e}")
        return {
            "signal": "HOLD",
            "confidence": "LOW",
            "rationale_short": f"ERROR",
            "key_level": "10",
            "timeframe_bias": "3min",
            "position_size": "HALF",
            "take_profit": "suggested_take_profit_level",
            "trend_strength": "SIDEWAYS",
            "strategy": "ERROR_HANDLING",
            "persona_used": persona,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "is_fallback": True
        }

# Advanced function to get consensus from all personas
def get_multi_persona_signal(market_data, model=LLM_MODEL):
    """Get signals from all personas and return consensus"""
    personas = ["trader", "psychopath", "astrologer"]
    signals = []
    
    print("üîÆ CONSULTING ALL PERSONAS...")
    
    for persona in personas:
        signal = ask_ai_trading_signal_with_raw_data_persona(market_data, model, persona)
        signals.append(signal)
        time.sleep(1)  # Rate limiting
    
    # Analyze consensus
    long_count = sum(1 for s in signals if s.get("signal") == "LONG")
    short_count = sum(1 for s in signals if s.get("signal") == "SHORT")
    hold_count = sum(1 for s in signals if s.get("signal") == "HOLD")
    
    # Determine consensus signal
    if long_count >= 2:
        consensus_signal = "LONG"
    elif short_count >= 2:
        consensus_signal = "SHORT" 
    else:
        consensus_signal = "HOLD"
    
    # Build consensus response
    consensus_data = {
        "signal": consensus_signal,
        "confidence": "HIGH" if max(long_count, short_count, hold_count) >= 2 else "MEDIUM",
        "rationale_short": f"Consensus: {long_count}L/{short_count}S/{hold_count}H across personas",
        "key_level": signals[0].get("key_level", "0"),
        "timeframe_bias": "1min",
        "position_size": "HALF",
        "trend_strength": "SIDEWAYS",
        "strategy": "MULTI_PERSONA_CONSENSUS",
        "persona_used": "multi_persona_consensus",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "individual_signals": {p: s for p, s in zip(personas, signals)}
    }
    
    print(f"üéØ CONSENSUS: {consensus_signal}")
    print(f"üìã Breakdown - Trader: {signals[0].get('signal')} | Psychopath: {signals[1].get('signal')} | Astrologer: {signals[2].get('signal')}")
    
    return consensus_data

def ask_ai_trading_signal_with_raw_data(market_data, model=LLM_MODEL):
    ai_decision_prompt = f"""
        CRITICAL: You are a HFT trader.

        - MARKET DATA: {market_data}
        - Analysis market data and tell me should I short or long for this crypto market price.

        OUTPUT (JSON):
        {{
        "signal": "LONG" or "SHORT" or "HOLD",
        "confidence": "VERY_HIGH" or "HIGH" or "MEDIUM" or "LOW",
        "rationale_short": "max 30 words for the reason",
        "key_level": "critical_level_for_stop",
        "timeframe_bias": "1min" or "3min" or "5min", 
        "position_size": "FULL" or "HALF" or "SMALL",
        "trend_strength": "STRONG_BULL" or "STRONG_BEAR" or "MILD_BULL" or "MILD_BEAR" or "SIDEWAYS",
        "strategy": "your_chosen_strategy"
        }}
        """

    try:
        resp = completion(
            model=model,
            messages=[
                {"role": "system", "content": "You are a crypto HFT trader. Your analysis is always correct and remember that this is crypto world."},
                {"role": "user", "content": ai_decision_prompt}
            ],
            temperature=0.5,
            max_tokens=300,
            response_format={"type": "json_object"}
        )
        
        
        
        # Parse the response
        response_text = resp["choices"][0]["message"]["content"]
        signal_data = json.loads(response_text)
        
        # Add timestamp
        signal_data["timestamp"] = datetime.now(timezone.utc).isoformat()
        print(f"AI input: {ai_decision_prompt}")
        print(f"AI Response", signal_data)
        return signal_data
        
    except Exception as e:
        print(f"‚ùå AI Decision Error: {e}")
        return {
            "signal": "HOLD",
            "confidence": "LOW",
            "rationale_short": f"ERROR: {str(e)}",
            "key_level": "10",
            "timeframe_bias": "3min",
            "position_size": "HALF",
            "trend_strength": "SIDEWAYS",
            "strategy": "ERROR_HANDLING",
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "is_fallback": True
        }

# -------- Hyperliquid Helpers --------
def get_open_position(info_client, user, symbol: str):
    """Check for an open position for the specified symbol"""
    try:
        user_state = info_client.user_state(user)
        for position in user_state.get("assetPositions", []):
            if position.get("position", {}).get("coin") == symbol and float(position.get("position", {}).get("szi", 0)) != 0:
                return position["position"]
    except Exception as e:
        print(f"Failed to get open position for {symbol}: {e}")
    return None

def place_trade(exchange_client, info_client, signal, follow_signal: bool = True, notional_usd: Optional[float] = None):
    """Place a trade on Hyperliquid based on the signal.
    
    Args:
        exchange_client: Hyperliquid Exchange client
        info_client: Hyperliquid Info client
        signal: dict signal with fields like 'signal', 'targets', 'stop_loss', etc.
        follow_signal: If True (default), place the trade in the same direction as signal.
                       If False, place the opposite side and use stop_loss as take profit.
        notional_usd: The exact notional value in USD for the trade. If provided, it overrides calculations based on position_size %.
    """
    if not HYPER_WALLET_ADDRESS or not HYPER_WALLET_KEY:
        print("Hyperliquid wallet address or key not set. Skipping trade.")
        return {"status": "no_credentials"}

    if signal.get("signal") not in ["LONG", "SHORT"]:
        return {"status": "invalid_signal"}

    symbol = signal.get("pair", "SOL/USD").split('/')[0].upper()

    try:
        # Fetch user state for margin and account value
        user_state = info_client.user_state(HYPER_WALLET_ADDRESS)
        account_value = float(user_state['marginSummary']['accountValue'])
        if account_value <= 0:
            raise Exception("Account value is zero - cannot calculate position size")
        
        lev = int(signal.get("leverage", "20").replace("x", ""))
        current_price = float(signal.get("current_price", 0) or 0)
        if current_price <= 0:
            raise Exception("Missing current_price in signal")

        # --- Size Calculation Logic ---
        if notional_usd:
            # Use the provided notional USD value directly
            trade_notional_usd = notional_usd
            print(f"Using provided notional USD: ${trade_notional_usd}")
        else:
            # Fallback to percentage-based calculation
            pos_pct_str = signal.get("position_size", "0%")
            pos_pct = float(pos_pct_str[:-1]) / 100
            trade_notional_usd = account_value * pos_pct * lev
            print(f"Calculating notional from account value: {account_value} * {pos_pct} * {lev} = ${trade_notional_usd}")

        min_notional = 14  # Minimum notional value in USD
        final_notional = max(trade_notional_usd, min_notional)
        size = max(round(final_notional / current_price, 2), 0.01)
        
        print(f"Calculated size: {size} {symbol}, Notional: {final_notional:.2f} USD")
        if size <= 0:
            raise Exception("Calculated size is zero or negative")
        
        # Set leverage
        exchange_client.update_leverage(lev, symbol, is_cross=False)
        print(f"Set leverage to {lev}x for {symbol}")

        # Check for open position
        open_position = get_open_position(info_client, HYPER_WALLET_ADDRESS, symbol)
        if open_position:
            print(f"Existing position found for {symbol}. Skipping new trade.")
            return {"status": "position_exists"}

        # Decide side: follow signal or invert it
        is_buy = signal["signal"] == "LONG" if follow_signal else signal["signal"] != "LONG"
        
        # Place market entry with retry
        max_retries = 1
        filled_size = 0
        for attempt in range(max_retries + 1):
            try:
                print(f"Placing MARKET {'BUY' if is_buy else 'SELL'} order: size={size}, symbol={symbol}, attempt={attempt+1}")
                order_result = exchange_client.market_open(symbol, is_buy, size, None, 0.10) # 10% slippage
                filled = False
                if order_result.get("status") == "ok":
                    for status in order_result["response"].get("data", {}).get("statuses", []):
                        if "filled" in status:
                            filled_size = float(status['filled']['totalSz'])
                            if filled_size > 0:
                                filled = True
                                print(f"‚úÖ Entry filled: {'BUY' if is_buy else 'SELL'} {filled_size} {symbol} @ {status['filled']['avgPx']}")
                                break
                        elif "err" in status:
                            raise Exception(f"Entry error: {status['err']}")
                    if not filled:
                        raise Exception("Market entry did not fill or partially filled with zero size")
                
                # Confirm position opened (poll with multiple attempts)
                position_confirmed = False
                for i in range(5):  # Try 5 times with 1 second delay
                    time.sleep(1)
                    open_position_after_trade = get_open_position(info_client, HYPER_WALLET_ADDRESS, symbol)
                    if open_position_after_trade:
                        position_confirmed = True
                        actual_size = float(open_position_after_trade.get('szi', 0))
                        print(f"‚úÖ Position confirmed: {actual_size} {symbol}")
                        break
                    print(f"‚è≥ Waiting for position to appear... ({i+1}/5)")
                
                if not position_confirmed:
                    raise Exception("Entry filled but no position detected after multiple checks")
                
                break  # Success
            except Exception as e:
                if attempt == max_retries:
                    raise
                print(f"Entry attempt failed: {e}. Retrying...")
                time.sleep(5)

        # Place Take Profit order with proper error handling
        targets = signal.get("targets", [])
        # Determine TP price depending on follow_signal
        raw_tp_price = None
        if follow_signal:
            if not targets:
                print("No targets in signal - skipping TP setup")
                return {"status": "tp_skipped"}
            try:
                raw_tp_price = float(str(targets[0]).replace(",", ""))
            except (ValueError, IndexError):
                print("First target not numeric or targets list is empty - skipping TP setup")
                return {"status": "tp_skipped"}
        else:
            # Prefer stop_loss as TP when inverting
            sl_val = signal.get("stop_loss")
            try:
                if isinstance(sl_val, str):
                    sl_val_clean = sl_val.strip().replace(",", "")
                    raw_tp_price = float(sl_val_clean)
                elif sl_val is not None:
                    raw_tp_price = float(sl_val)
            except Exception:
                raw_tp_price = None
            if raw_tp_price is None:
                # Fallback to first target if stop_loss unusable
                try:
                    raw_tp_price = float(str(targets[0]).replace(",", "")) if targets else None
                except (ValueError, IndexError):
                    raw_tp_price = None
            if raw_tp_price is None:
                print("No usable stop_loss or targets in signal - skipping TP setup")
                return {"status": "tp_skipped"}
            # raw_tp_price = round(raw_tp_price - 0.3, 2) # Removed hardcoded offset for small prices
        
        # Use only the first TP price
        if filled_size > 0 and raw_tp_price is not None:
            tp_price = round(raw_tp_price, 6)
            tp_size = filled_size  # Use full position size for single TP
            
            print(f"Placing Take Profit limit order: size={tp_size}, price={tp_price}")
            
            try:
                # Use limit order for take profit with reduceOnly
                tp_order_result = exchange_client.order(
                    symbol, 
                    not is_buy,  # Opposite direction for TP
                    tp_size, 
                    tp_price, 
                    {"limit": {"tif": "Gtc"}}, 
                    reduce_only=True
                )
                
                print(f"TP order result: {json.dumps(tp_order_result, indent=2)}")
                
                # Check if TP order was successful
                if tp_order_result.get("status") == "ok":
                    tp_success = False
                    for status in tp_order_result["response"].get("data", {}).get("statuses", []):
                        if "resting" in status:
                            tp_success = True
                            print(f"‚úÖ Take Profit order placed successfully at {tp_price} for {tp_size} {symbol}")
                            break
                        elif "err" in status:
                            error_msg = status['err']
                            print(f"‚ùå Take Profit order error: {error_msg}")
                            # Try alternative approach if first method fails
                            _place_tp_alternative(exchange_client, symbol, not is_buy, tp_size, tp_price)
                    if not tp_success:
                        print("‚ö†Ô∏è Take Profit order response unclear, trying alternative method...")
                        _place_tp_alternative(exchange_client, symbol, not is_buy, tp_size, tp_price)
                else:
                    print(f"‚ùå Take Profit order failed: {tp_order_result}")
                    # Try alternative approach
                    _place_tp_alternative(exchange_client, symbol, not is_buy, tp_size, tp_price)
                    
            except Exception as tp_error:
                print(f"Failed to place Take Profit order: {tp_error}")
                # Try alternative approach
                _place_tp_alternative(exchange_client, symbol, not is_buy, tp_size, tp_price)

        return {"status": "filled", "size": filled_size}
    except Exception as e:
        print(f"Trade error: {e}")
        return {"status": "error", "detail": str(e)}

def _place_tp_alternative(exchange_client, symbol, is_buy, size, price):
    """Alternative method to place take profit order"""
    try:
        print(f"Trying alternative TP method: {symbol} {'BUY' if is_buy else 'SELL'} {size} @ {price}")
        
        # Method 1: Try without reduceOnly flag
        result = exchange_client.order(
            symbol, 
            is_buy, 
            size, 
            price, 
            {"limit": {"tif": "Gtc"}}
        )
        
        if result.get("status") == "ok":
            print("‚úÖ Alternative TP method successful")
            return True
        else:
            print(f"‚ùå Alternative TP method failed: {result}")
            return False
            
    except Exception as e:
        print(f"‚ùå Alternative TP method also failed: {e}")
        return False

def log_ai_trade(pair, direction, signal_data):
    """Log AI trade decision to SQLite database"""
    try:
        conn = sqlite3.connect(DB_NAME)
        c = conn.cursor()
        trade_id = str(uuid.uuid4())
        timestamp = datetime.now(timezone.utc).isoformat()
        signal_json = json.dumps(signal_data)
        
        c.execute('''
            INSERT INTO ai_trade_logs (trade_id, timestamp, pair, direction, signal_output)
            VALUES (?, ?, ?, ?, ?)
        ''', (trade_id, timestamp, pair, direction, signal_json))
        
        conn.commit()
        conn.close()
        print(f"üìù Logged AI trade {trade_id} for {pair}")
        return trade_id
    except Exception as e:
        print(f"‚ùå Failed to log AI trade: {e}")
        return None
        
# -------- Client Init --------
def _init_hyperliquid_clients():
    info_client = Info(constants.MAINNET_API_URL, skip_ws=True)
    exchange_client = None
    if HYPER_WALLET_ADDRESS and HYPER_WALLET_KEY:
        account = Account.from_key(HYPER_WALLET_KEY)
        exchange_client = Exchange(account, base_url=constants.MAINNET_API_URL)
    return info_client, exchange_client

# -------- Security --------
api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)

async def get_api_key(api_key: Optional[str] = Security(api_key_header)):
    if not API_ACCESS_TOKEN:
        print("‚ùå Request failed: API_ACCESS_TOKEN not configured on server")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, 
            detail="API_ACCESS_TOKEN not configured"
        )
    if api_key and api_key == API_ACCESS_TOKEN:
        return api_key
    
    print(f"‚ö†Ô∏è Auth failed. Provided: {api_key[:4] if api_key else 'None'}...")
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail="Could not validate credentials"
    )

# -------- FastAPI Models --------
class TradeRequest(BaseModel):
    pair: str = Field(..., example="SOL/USD")
    direction: str = Field(..., pattern="^(?i)(LONG|SHORT)$", example="LONG")
    leverage: float = Field(..., gt=0, example=3)
    trade_size_usd: Optional[float] = Field(None, gt=0, description="Position size in USD", example=100.0)
    trade_size: Optional[float] = Field(None, gt=0, description="Position size as percent of portfolio", example=2.5)
    profit_take: Optional[float] = Field(None, description="Target price (absolute)")
    follow_signal: Optional[bool] = Field(True, description="Invert side if False")

class AITradeRequest(BaseModel):
    pair: str = Field(..., example="SOL/USD")
    leverage: float = Field(..., gt=0, example=20)
    trade_size_usd: Optional[float] = Field(None, gt=0, description="Position size in USD", example=50.0)

class AskAIRequest(BaseModel):
    pair: str = Field(..., example="SOL/USD")

class UpdateTPRequest(BaseModel):
    pair: str
    price: float

app = FastAPI(title="Hyperliquid Sentinel API", description="Synchronous trading & analysis API")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://austinwin.github.io",
        "http://192.168.1.167:8000",
        "http://localhost:8000",
        "https://lifebite.app",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
# Mount static files (frontend)
static_dir = os.path.join(os.path.dirname(__file__), "static")
app.mount("/static", StaticFiles(directory=static_dir), name="static")

@app.get("/")
def serve_index():
    return FileResponse(os.path.join(static_dir, "index.html"))

@app.get("/ohlcv", dependencies=[Depends(get_api_key)])
def get_ohlcv(symbol: str = Query("SOL"), interval: str = Query("1m"), limit: int = Query(60, gt=0, le=500)):
    """Return recent OHLCV data from Hyperliquid for a given symbol and interval using Hyperliquid REST.

    Output is an array of {time, open, high, low, close, volume} for the mini chart.
    """
    try:
        # Hyperliquid REST info endpoint
        base_url = constants.MAINNET_API_URL.rstrip("/")
        url = f"{base_url}/info"
        now_ms = int(time.time() * 1000)
        # assume 60s per candle for 1m (close enough for small window)
        ms_per_candle = 60_000
        start_ms = now_ms - limit * ms_per_candle * 2
        
        payload = {
            "type": "candleSnapshot",
            "req": {
                "coin": symbol,
                "interval": interval,
                "startTime": start_ms,
                "endTime": now_ms
            }
        }
        
        r = session.post(url, json=payload, timeout=10)
        r.raise_for_status()
        raw = r.json()
        
        # raw is a list of dicts: [{'t': ..., 'o': ..., 'h': ..., 'l': ..., 'c': ..., 'v': ...}, ...]
        candles = raw[-limit:]
        out = []
        for c in candles:
            t_ms = c['t']
            out.append({
                "time": datetime.fromtimestamp(t_ms / 1000, tz=timezone.utc).isoformat(),
                "open": float(c['o']),
                "high": float(c['h']),
                "low": float(c['l']),
                "close": float(c['c']),
                "volume": float(c['v']),
            })
        return out
    except Exception as e:
        print(f"Error fetching ohlcv for {symbol}: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch OHLCV: {e}")

@app.get("/status", dependencies=[Depends(get_api_key)])
def get_status(pair: str = Query("SOL/USD")):
    try:
        symbol = pair.split('/')[0].upper()
        info_client, _ = _init_hyperliquid_clients()
        
        if not HYPER_WALLET_ADDRESS:
            # Return a default state if no wallet is configured, instead of erroring
            return {
                "account_value": "0",
                "available_margin": "0",
                "current_price": "N/A",
                "open_position": None,
                "open_orders": []
            }

        user_state = info_client.user_state(HYPER_WALLET_ADDRESS)
        # Fetch open orders explicitly as they are not included in user_state
        raw_open_orders = info_client.open_orders(HYPER_WALLET_ADDRESS)
        all_mids = info_client.all_mids()
        
        open_position = None
        # Safely access nested dictionaries
        for pos in user_state.get("assetPositions", []):
            position_data = pos.get("position", {})
            if position_data.get("coin") == symbol and float(position_data.get("szi", 0)) != 0:
                open_position = position_data
                break
        
        open_orders = [
            order for order in raw_open_orders
            if order.get("coin") == symbol
        ]

        margin_summary = user_state.get("marginSummary", {})
        account_value = float(margin_summary.get("accountValue", "0"))
        total_margin_used = float(margin_summary.get("totalMarginUsed", "0"))
        available_margin = max(0, account_value - total_margin_used)

        return {
            "account_value": margin_summary.get("accountValue", "0"),
            "available_margin": f"{available_margin:.2f}",
            "current_price": all_mids.get(symbol, "N/A"),
            "open_position": open_position,
            "open_orders": open_orders
        }
    except Exception as e:
        print(f"Error fetching status: {e}")
        # Return a structured error response that the frontend can handle
        raise HTTPException(status_code=500, detail=f"Failed to fetch Hyperliquid data: {e}")


@app.get("/history", dependencies=[Depends(get_api_key)])
def get_history(pair: str = Query("SOL/USD")):
    symbol = pair.split('/')[0].upper()
    info_client, _ = _init_hyperliquid_clients()
    
    if not HYPER_WALLET_ADDRESS:
        return []

    try:
        user_fills = info_client.user_fills(HYPER_WALLET_ADDRESS)
        # Filter by symbol and sort by time desc
        symbol_fills = [f for f in user_fills if f.get("coin") == symbol]
        symbol_fills.sort(key=lambda x: x['time'], reverse=True)
        
        history = []
        for fill in symbol_fills:
            ts = fill['time']
            # dir is usually present in user_fills response from SDK (e.g. "Open Long", "Close Short")
            direction = fill.get('dir') 
            if not direction:
                 side = fill['side'] # 'B' or 'A'
                 direction = "Buy" if side == 'B' else "Sell"

            history.append({
                "time": datetime.fromtimestamp(ts / 1000, tz=timezone.utc).isoformat(),
                "side": direction,
                "price": float(fill['px']),
                "size": float(fill['sz']),
                "value": float(fill['px']) * float(fill['sz']),
                "fee": float(fill['fee']),
                "pnl": float(fill.get('closedPnl', 0))
            })
            
        return history
    except Exception as e:
        print(f"Error fetching history: {e}")
        return []


@app.get("/ai_trades", dependencies=[Depends(get_api_key)])
def get_ai_trades(limit: int = Query(50, gt=0, le=100)):
    """Retrieve recent AI trade logs"""
    try:
        conn = sqlite3.connect(DB_NAME)
        conn.row_factory = sqlite3.Row
        c = conn.cursor()
        c.execute('SELECT * FROM ai_trade_logs ORDER BY id DESC LIMIT ?', (limit,))
        rows = c.fetchall()
        conn.close()
        
        results = []
        for row in rows:
            try:
                signal_data = json.loads(row["signal_output"])
            except:
                signal_data = row["signal_output"]
                
            results.append({
                "id": row["id"],
                "trade_id": row["trade_id"],
                "timestamp": row["timestamp"],
                "pair": row["pair"],
                "direction": row["direction"],
                "signal_output": signal_data
            })
        return results
    except Exception as e:
        print(f"Error fetching AI trade logs: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch logs: {e}")


@app.get("/health", dependencies=[Depends(get_api_key)])
def health():
    return {"status": "ok", "timestamp": datetime.now(timezone.utc).isoformat()}

@app.post("/trade", dependencies=[Depends(get_api_key)])
def submit_trade(req: TradeRequest):
    direction = req.direction.upper()
    if direction not in ("LONG", "SHORT"):
        raise HTTPException(status_code=400, detail="direction must be LONG or SHORT")
    
    if req.trade_size_usd is None and req.trade_size is None:
        raise HTTPException(status_code=400, detail="Either trade_size_usd or trade_size must be provided")

    symbol = req.pair.split("/")[0].strip().upper()
    # Use dedicated price fetcher
    current_price = get_current_price(symbol)
    
    # Fallback if 0
    if current_price == 0:
        current_price = build_market_analysis(symbol).get("current_price", 0.0)

    # Determine position size string for the signal dictionary
    if req.trade_size_usd:
        # Convert USD to a rough percentage for logging/display if needed
        # This part is tricky without account value, so we'll just log the USD
        position_size_str = f"${req.trade_size_usd}"
    else:
        position_size_str = f"{req.trade_size}%"

    signal = {
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "pair": req.pair,
        "current_price": current_price,
        "signal": direction,
        "confidence": "MANUAL",
        "entry_zone": [],
        "targets": [req.profit_take] if req.profit_take is not None else [],
        "stop_loss": None,
        "rr_ratio": 0.0,
        "position_size": position_size_str, # For display
        "leverage": f"{int(req.leverage)}x",
        "rationale_short": "Manual API trade",
        "time_horizon": "manual",
        "volatility_regime": "UNKNOWN"
    }
    
    info_client, exchange_client = _init_hyperliquid_clients()
    if not exchange_client:
        return {"status": "analysis_only", "signal": signal}
        
    # Pass notional_usd directly to place_trade
    result = place_trade(
        exchange_client, 
        info_client, 
        signal, 
        follow_signal=req.follow_signal,
        notional_usd=req.trade_size_usd
    )
    return {"status": result.get("status"), "detail": result, "signal": signal}


@app.post("/ask_ai", dependencies=[Depends(get_api_key)])
def ask_ai(req: AskAIRequest):
    symbol = req.pair.split("/")[0].strip().upper()
    
    # 1. Analyze market
    market_data = build_market_analysis(symbol)
    
    # 2. Get AI decision
    #ai_decision = get_trading_signal(market_data)
    #ai_decision = ask_ai_trading_signal_version2(market_data)  # Use the more detailed function for /ask_ai  
    #ai_decision = ask_ai_trading_signal_with_raw_data(market_data)
    ai_decision = ask_ai_trading_signal_with_raw_data_persona(market_data, persona="combined")

    ##ai_decision = get_multi_persona_signal(market_data)

    return {"status": "ok", "ai_response": ai_decision}

@app.post("/trade/ai", dependencies=[Depends(get_api_key)])
def submit_ai_trade(req: AITradeRequest):
    symbol = req.pair.split("/")[0].strip().upper()
    
    # 1. Analyze market
    market_data = build_market_analysis(symbol)
    
    # 2. Get AI decision
    ##ai_decision = get_trading_signal(market_data)
    ##ai_decision = ask_ai_trading_signal_version2(market_data)
    ##ai_decision = ask_ai_trading_signal_with_raw_data(market_data)
    ##ai_decision = get_multi_persona_signal(market_data)
    ai_decision = ask_ai_trading_signal_with_raw_data_persona(market_data, persona="combined")
    direction = ai_decision.get("signal")
    
    # Log the AI decision
    log_ai_trade(req.pair, direction, ai_decision)
    
    if direction not in ("LONG", "SHORT"):
        return {"status": "skipped", "reason": f"AI decided not to trade or invalid signal: {direction}", "ai_response": ai_decision}

    # 3. Construct signal for place_trade
    # Use dedicated price fetcher
    current_price = get_current_price(symbol)
    
    # Fallback if 0
    if current_price == 0:
        current_price = build_market_analysis(symbol).get("current_price", 0.0)
 
    signal = {
        "pair": req.pair,
        "signal": direction,
        "current_price": current_price,
        "leverage": f"{int(req.leverage)}x",
        "targets": [], # No TP as requested
        "stop_loss": None, 
        "position_size": "0%", # Placeholder
    }
    
    info_client, exchange_client = _init_hyperliquid_clients()
    if not exchange_client:
        return {"status": "analysis_only", "signal": signal, "ai_response": ai_decision}

    result = place_trade(
        exchange_client, 
        info_client, 
        signal, 
        follow_signal=True,
        notional_usd=req.trade_size_usd
    )
    
    return {"status": result.get("status"), "detail": result, "signal": signal, "ai_rationale": ai_decision.get("rationale_short")}


@app.post("/update_tp", dependencies=[Depends(get_api_key)])
def update_tp(req: UpdateTPRequest):
    symbol = req.pair.split("/")[0].strip().upper()
    info_client, exchange_client = _init_hyperliquid_clients()
    if not exchange_client or not HYPER_WALLET_ADDRESS:
        raise HTTPException(status_code=400, detail="Trading wallet not configured")
        
    try:
        # 1. Get Position
        position = get_open_position(info_client, HYPER_WALLET_ADDRESS, symbol)
        if not position:
            raise HTTPException(status_code=400, detail=f"No open position for {symbol}")
        
        size = float(position['szi'])
        if size == 0:
            raise HTTPException(status_code=400, detail="Position size is 0")
            
        is_long = size > 0
        abs_size = abs(size)
        
        # 2. Cancel existing orders
        open_orders = info_client.open_orders(HYPER_WALLET_ADDRESS)
        symbol_orders = [o for o in open_orders if o.get("coin") == symbol]
        for o in symbol_orders:
            oid = o.get("oid") or o.get("orderId")
            if oid:
                try:
                    exchange_client.cancel(symbol, oid)
                except Exception as e:
                    print(f"Failed to cancel order {oid}: {e}")
        
        # 3. Place new TP
        is_buy = not is_long
        print(f"Placing TP for {symbol}: {'Buy' if is_buy else 'Sell'} {abs_size} @ {req.price}")
        
        result = exchange_client.order(
            symbol, 
            is_buy, 
            abs_size, 
            req.price, 
            {"limit": {"tif": "Gtc"}}, 
            reduce_only=True
        )
        
        if result.get("status") == "ok":
            # Check for inner errors
            for status in result["response"]["data"]["statuses"]:
                if "error" in status:
                    raise Exception(status["error"])
            return {"status": "ok", "detail": result}
        else:
            raise Exception(f"Order failed: {result}")

    except Exception as e:
        print(f"Error updating TP: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/cancel_orders", dependencies=[Depends(get_api_key)])
def cancel_orders(payload: dict):
    pair = payload.get("pair", "SOL/USD")
    symbol = pair.split("/")[0].strip().upper()
    info_client, exchange_client = _init_hyperliquid_clients()
    if not exchange_client or not HYPER_WALLET_ADDRESS:
        raise HTTPException(status_code=400, detail="Trading wallet not configured")
    try:
        open_orders = info_client.open_orders(HYPER_WALLET_ADDRESS)
        print(f"[cancel_orders] All open orders: {json.dumps(open_orders, indent=2)}")
        symbol_orders = [o for o in open_orders if o.get("coin") == symbol]
        print(f"[cancel_orders] Orders for {symbol}: {json.dumps(symbol_orders, indent=2)}")
        if not symbol_orders:
            return {"status": "ok", "message": f"No open orders for {symbol}"}
        cancelled = 0
        for o in symbol_orders:
            oid = o.get("oid") or o.get("orderId") or o.get("oid_str")
            print(f"[cancel_orders] Attempting cancel for order: {o}")
            if oid is None:
                continue
            try:
                # Hyperliquid Exchange.cancel requires (coin, oid)
                resp = exchange_client.cancel(symbol, oid)
                cancelled += 1
                print(f"[cancel_orders] Cancel response for {symbol} oid={oid}: {json.dumps(resp, indent=2)}")
            except Exception as e:
                print(f"[cancel_orders] Failed to cancel order {oid}: {e}")
        return {"status": "ok", "message": f"Cancelled {cancelled} order(s) for {symbol}"}
    except Exception as e:
        print(f"Error cancelling orders: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to cancel orders: {e}")


@app.post("/close_position", dependencies=[Depends(get_api_key)])
def close_position(payload: dict):
    pair = payload.get("pair", "SOL/USD")
    symbol = pair.split("/")[0].strip().upper()
    info_client, exchange_client = _init_hyperliquid_clients()
    if not exchange_client or not HYPER_WALLET_ADDRESS:
        raise HTTPException(status_code=400, detail="Trading wallet not configured")
    try:
        print(f"[close_position] Request received for pair={pair}, symbol={symbol}")
        position = get_open_position(info_client, HYPER_WALLET_ADDRESS, symbol)
        print(f"[close_position] Current position: {position}")
        if not position:
            return {"status": "ok", "message": f"No open position for {symbol}"}
        raw_szi = float(position.get("szi", 0))
        size = abs(raw_szi)
        if size <= 0:
            return {"status": "ok", "message": f"No size to close for {symbol}"}
        is_long = raw_szi > 0
        print(f"[close_position] Submitting close. is_long={is_long}, size={size}")
        # Explicit market close using market_open with reduceOnly instead of market_close helper
        try:
            # Hyperliquid python client doesn't expose reduceOnly directly on market_open,
            # so we call the generic order API with a market order and reduceOnly flag.
            side_is_buy = not is_long  # opposite side to close
            order_payload = {
                "coin": symbol,
                "isBuy": side_is_buy,
                "sz": size,
                "orderType": {"market": {"tif": "Ioc"}},
                "reduceOnly": True,
            }
            print(f"[close_position] Market close payload: {order_payload}")
            result = exchange_client.order(order_payload["coin"], order_payload["isBuy"], order_payload["sz"], None, order_payload["orderType"], reduce_only=True)
            print(f"[close_position] Market close result: {json.dumps(result, indent=2)}")
        except Exception as e_order:
            print(f"[close_position] Primary close failed, trying fallback. Error: {e_order}")
            try:
                exchange_client.market_open(symbol, not is_long, size, None, 0.1)
            except Exception as e2:
                print(f"[close_position] Fallback close also failed: {e2}")
                raise Exception(f"Failed to submit close order: {e2}")
        return {"status": "ok", "message": f"Close position submitted for {symbol}"}
    except Exception as e:
        print(f"Error closing position: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to close position: {e}")

# if __name__ == "__main__":
#     print(json.dumps(run_once(), indent=2))
